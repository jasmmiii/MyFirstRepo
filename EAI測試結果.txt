EAI測試結果

===========PCTF============
<root>
  <InputData>
    <ORG/>
    <TYPE/>
    <CARDHOLDER>4573780000000006</CARDHOLDER>
    <EMG/>
    <BLOCK-CDE/>
    <NEW-ACCT/>
    <DATE-TRANS-EFFECT/>
    <UPDATE-EXCEPTION-FILE/>
  </InputData>
  <OutputData>
    <ORG>001  </ORG>
    <TYPE>370 </TYPE> 利被商務玉璽卡 VISA
    <CARDHOLDER>4573780000000006</CARDHOLDER>
    <EMG>         </EMG>
    <BLOCK-CDE>L</BLOCK-CDE>
    <NEW-ACCT>4573780000000105</NEW-ACCT>
    <DATE-TRANS-EFFECT>10092025</DATE-TRANS-EFFECT>
    <UPDATE-EXCEPTION-FILE>N</UPDATE-EXCEPTION-FILE>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>
</root>


<root>
  <InputData>
    <ORG/>
    <TYPE/>
    <CARDHOLDER>4025128950000127</CARDHOLDER>
    <EMG/>
    <BLOCK-CDE/>
    <NEW-ACCT/>
    <DATE-TRANS-EFFECT/>
    <UPDATE-EXCEPTION-FILE/>
  </InputData>
  <OutputData>
    <ORG>001  </ORG>
    <TYPE>195 </TYPE>  
    <CARDHOLDER>4025128950000127</CARDHOLDER>
    <EMG>         </EMG>
    <BLOCK-CDE>L</BLOCK-CDE>
    <NEW-ACCT>4025128950000309</NEW-ACCT>
    <DATE-TRANS-EFFECT>10092025</DATE-TRANS-EFFECT>
    <UPDATE-EXCEPTION-FILE>N</UPDATE-EXCEPTION-FILE>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>
</root>
 ONE卡 type: 191 195 291 391 395 397


4573780000000014
<root>
  <InputData>
    <ORG/>
    <TYPE/>
    <CARDHOLDER>4573780000000014 </CARDHOLDER>
    <EMG/>
    <BLOCK-CDE/>
    <NEW-ACCT/>
    <DATE-TRANS-EFFECT/>
    <UPDATE-EXCEPTION-FILE/>
  </InputData>
  <OutputData>
    <ORG>001  </ORG>
    <TYPE>370 </TYPE>
    <CARDHOLDER>4573780000000014</CARDHOLDER>
    <EMG>         </EMG>
    <BLOCK-CDE>L</BLOCK-CDE>
    <NEW-ACCT>4573780000000204</NEW-ACCT>
    <DATE-TRANS-EFFECT>11092025</DATE-TRANS-EFFECT>
    <UPDATE-EXCEPTION-FILE>N</UPDATE-EXCEPTION-FILE>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>
</root>




=============================PCMH===============================

0006新卡號 4573780000000105  error?
<root>
  <OutputData>
    <ACCT-DATA-1>370</ACCT-DATA-1>
    <ACCT-DATA-2>4573780000000105  </ACCT-DATA-2>
    <TxRetMsg>INPUT DATA ERROR</TxRetMsg>
  </OutputData>
</root>


PCMH xml 4563148170008211 有無改參數都成功
<OutputData>
    <ACCT-DATA-1>217</ACCT-DATA-1>
    <ACCT-DATA-2>4563148170008203  </ACCT-DATA-2>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>

0127新卡號 4025128950000309 有無改參數都成功
<OutputData>
    <ACCT-DATA-1>195</ACCT-DATA-1>
    <ACCT-DATA-2>4025128950000309  </ACCT-DATA-2>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>

0014新卡號 4573780000000204 
<OutputData>
    <ACCT-DATA-1>370</ACCT-DATA-1>
    <ACCT-DATA-2>4573780000000204  </ACCT-DATA-2>
    <TxRetMsg>INPUT DATA ERROR</TxRetMsg>
  </OutputData>

<OutputData> OK了
    <ACCT-DATA-1>370</ACCT-DATA-1>
    <ACCT-DATA-2>4573780000000204  </ACCT-DATA-2>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>


===================TODO=====================
補卡單上多按鈕 補卡 
編輯時才可點
原本輸入新卡號(有指定卡號的)
點補卡後直接帶入無指定的 純顯示 createtd? 


action code 看要不要做控管 只有那八種type可以修改 防止誤敲報錯
action code & Expired date 都讓user敲


===================解析xml=====================


package com.scsb.cfms.util;

import org.springframework.stereotype.Component;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;
import java.io.IOException;
import java.io.StringReader;
import java.util.Optional;

@Component
public class XmlCardParser {

    // 建議使用 Logger 而非 System.err
    // private static final Logger logger = LogManager.getLogger(XmlCardParser.class); 

    /**
     * 安全地解析 EAI 回傳的 XML 字串，並使用 XPath 提取指定標籤的值。
     *
     * @param xmlString EAI 回傳的完整 XML 字串。
     * @param tagName 要提取值的標籤名稱，例如 "NEW-ACCT" 或 "TxRetMsg"。
     * @return 提取到的標籤值，如果找不到或解析失敗則返回空 Optional。
     */
    public Optional<String> extractValueFromXml(String xmlString, String tagName) {
        if (xmlString == null || xmlString.isBlank() || tagName == null || tagName.isBlank()) {
            return Optional.empty();
        }

        try {
            // =====================================
            // 1. 安全初始化 XML 解析器 (XXE 防禦)
            // =====================================
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

            // *** 關鍵的安全設定：禁用外部實體解析 ***
            factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
            factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
            factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
            factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
            factory.setExpandEntityReferences(false);
            // **********************************

            DocumentBuilder builder = factory.newDocumentBuilder();
            
            // 2. 解析 XML 字串
            Document document = builder.parse(new InputSource(new StringReader(xmlString)));
            
            // =====================================
            // 3. 使用 XPath 進行精確查詢
            // =====================================
            XPath xpath = XPathFactory.newInstance().newXPath();

            // XPath 表達式：//OutputData/tagName
            // 意義：在 XML 文件中的任何位置，找到 <OutputData> 標籤下的 <tagName> 標籤。
            // 這樣可以避免 <InputData> 中同名標籤的干擾。
            String expression = "//OutputData/" + tagName;
            
            // 執行 XPath 查詢，並期望返回一個單一節點 (Node)
            Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);

            if (node != null) {
                // 取得節點內容，並移除前後空白
                String value = node.getTextContent().trim();
                return Optional.of(value);
            }

        } catch (Exception e) {
            // 實務上應該使用 logger.error(...)
            System.err.println("XML 解析錯誤，標籤: " + tagName + ", 錯誤訊息: " + e.getMessage());
        }
        
        return Optional.empty(); // XPath 查詢失敗或節點為空則返回空
    }

    // ... (Main 測試方法可以保留或刪除) ...
}





    // 測試範例
    public static void main(String[] args) {
        String pctfXmlOutput = "<root>\n" +
                "  <InputData>\n" +
                "    <ORG/>\n" +
                "    <TYPE/>\n" +
                "    <CARDHOLDER>4573780000000006</CARDHOLDER>\n" +
                "    <EMG/>\n" +
                "    <BLOCK-CDE/>\n" +
                "    <NEW-ACCT/>\n" +
                "    <DATE-TRANS-EFFECT/>\n" +
                "    <UPDATE-EXCEPTION-FILE/>\n" +
                "  </InputData>\n" +
                "  <OutputData>\n" +
                "    <ORG>001  </ORG>\n" +
                "    <TYPE>370 </TYPE>\n" +
                "    <CARDHOLDER>4573780000000006</CARDHOLDER>\n" +
                "    <EMG>         </EMG>\n" +
                "    <BLOCK-CDE>L</BLOCK-CDE>\n" +
                "    <NEW-ACCT>4573780000000105</NEW-ACCT>\n" +
                "    <DATE-TRANS-EFFECT>10092025</DATE-TRANS-EFFECT>\n" +
                "    <UPDATE-EXCEPTION-FILE>N</UPDATE-EXCEPTION-FILE>\n" +
                "    <TxRetMsg>維護成功</TxRetMsg>\n" +
                "  </OutputData>\n" +
                "</root>";

        Optional<String> newCardNumber = extractValueFromXml(pctfXmlOutput, "NEW-ACCT");
        
        if (newCardNumber.isPresent()) {
            System.out.println("提取到的新卡號: " + newCardNumber.get()); // 輸出: 4573780000000105
        } else {
            System.out.println("無法提取新卡號。");
        }
    }
}







