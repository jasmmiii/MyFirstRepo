EAI測試結果

===========PCTF============
<root>
  <InputData>
    <ORG/>
    <TYPE/>
    <CARDHOLDER>4573780000000006</CARDHOLDER>
    <EMG/>
    <BLOCK-CDE/>
    <NEW-ACCT/>
    <DATE-TRANS-EFFECT/>
    <UPDATE-EXCEPTION-FILE/>
  </InputData>
  <OutputData>
    <ORG>001  </ORG>
    <TYPE>370 </TYPE> 利被商務玉璽卡 VISA
    <CARDHOLDER>4573780000000006</CARDHOLDER>
    <EMG>         </EMG>
    <BLOCK-CDE>L</BLOCK-CDE>
    <NEW-ACCT>4573780000000105</NEW-ACCT>
    <DATE-TRANS-EFFECT>10092025</DATE-TRANS-EFFECT>
    <UPDATE-EXCEPTION-FILE>N</UPDATE-EXCEPTION-FILE>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>
</root>


<root>
  <InputData>
    <ORG/>
    <TYPE/>
    <CARDHOLDER>4025128950000127</CARDHOLDER>
    <EMG/>
    <BLOCK-CDE/>
    <NEW-ACCT/>
    <DATE-TRANS-EFFECT/>
    <UPDATE-EXCEPTION-FILE/>
  </InputData>
  <OutputData>
    <ORG>001  </ORG>
    <TYPE>195 </TYPE>  
    <CARDHOLDER>4025128950000127</CARDHOLDER>
    <EMG>         </EMG>
    <BLOCK-CDE>L</BLOCK-CDE>
    <NEW-ACCT>4025128950000309</NEW-ACCT>
    <DATE-TRANS-EFFECT>10092025</DATE-TRANS-EFFECT>
    <UPDATE-EXCEPTION-FILE>N</UPDATE-EXCEPTION-FILE>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>
</root>
 ONE卡 type: 191 195 291 391 395 397


4573780000000014
<root>
  <InputData>
    <ORG/>
    <TYPE/>
    <CARDHOLDER>4573780000000014 </CARDHOLDER>
    <EMG/>
    <BLOCK-CDE/>
    <NEW-ACCT/>
    <DATE-TRANS-EFFECT/>
    <UPDATE-EXCEPTION-FILE/>
  </InputData>
  <OutputData>
    <ORG>001  </ORG>
    <TYPE>370 </TYPE>
    <CARDHOLDER>4573780000000014</CARDHOLDER>
    <EMG>         </EMG>
    <BLOCK-CDE>L</BLOCK-CDE>
    <NEW-ACCT>4573780000000204</NEW-ACCT>
    <DATE-TRANS-EFFECT>11092025</DATE-TRANS-EFFECT>
    <UPDATE-EXCEPTION-FILE>N</UPDATE-EXCEPTION-FILE>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>
</root>




=============================PCMH===============================

0006新卡號 4573780000000105  error?
<root>
  <OutputData>
    <ACCT-DATA-1>370</ACCT-DATA-1>
    <ACCT-DATA-2>4573780000000105  </ACCT-DATA-2>
    <TxRetMsg>INPUT DATA ERROR</TxRetMsg>
  </OutputData>
</root>


PCMH xml 4563148170008211 有無改參數都成功
<OutputData>
    <ACCT-DATA-1>217</ACCT-DATA-1>
    <ACCT-DATA-2>4563148170008203  </ACCT-DATA-2>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>

0127新卡號 4025128950000309 有無改參數都成功
<OutputData>
    <ACCT-DATA-1>195</ACCT-DATA-1>
    <ACCT-DATA-2>4025128950000309  </ACCT-DATA-2>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>

0014新卡號 4573780000000204 
<OutputData>
    <ACCT-DATA-1>370</ACCT-DATA-1>
    <ACCT-DATA-2>4573780000000204  </ACCT-DATA-2>
    <TxRetMsg>INPUT DATA ERROR</TxRetMsg>
  </OutputData>

<OutputData> OK了
    <ACCT-DATA-1>370</ACCT-DATA-1>
    <ACCT-DATA-2>4573780000000204  </ACCT-DATA-2>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>


===================TODO=====================
補卡單上多按鈕 補卡 
編輯時才可點
原本輸入新卡號(有指定卡號的)
點補卡後直接帶入無指定的 純顯示 createtd? 


action code 看要不要做控管 只有那八種type可以修改 防止誤敲報錯
action code & Expired date 都讓user敲


===================解析xml=====================


package com.scsb.cfms.util;

import org.springframework.stereotype.Component;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;
import java.io.IOException;
import java.io.StringReader;
import java.util.Optional;

@Component
public class XmlCardParser {

    // 建議使用 Logger 而非 System.err
    // private static final Logger logger = LogManager.getLogger(XmlCardParser.class); 

    /**
     * 安全地解析 EAI 回傳的 XML 字串，並使用 XPath 提取指定標籤的值。
     *
     * @param xmlString EAI 回傳的完整 XML 字串。
     * @param tagName 要提取值的標籤名稱，例如 "NEW-ACCT" 或 "TxRetMsg"。
     * @return 提取到的標籤值，如果找不到或解析失敗則返回空 Optional。
     */
    public Optional<String> extractValueFromXml(String xmlString, String tagName) {
        if (xmlString == null || xmlString.isBlank() || tagName == null || tagName.isBlank()) {
            return Optional.empty();
        }

        try {
            // =====================================
            // 1. 安全初始化 XML 解析器 (XXE 防禦)
            // =====================================
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

            // *** 關鍵的安全設定：禁用外部實體解析 ***
            factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
            factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
            factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
            factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
            factory.setExpandEntityReferences(false);
            // **********************************

            DocumentBuilder builder = factory.newDocumentBuilder();
            
            // 2. 解析 XML 字串
            Document document = builder.parse(new InputSource(new StringReader(xmlString)));
            
            // =====================================
            // 3. 使用 XPath 進行精確查詢
            // =====================================
            XPath xpath = XPathFactory.newInstance().newXPath();

            // XPath 表達式：//OutputData/tagName
            // 意義：在 XML 文件中的任何位置，找到 <OutputData> 標籤下的 <tagName> 標籤。
            // 這樣可以避免 <InputData> 中同名標籤的干擾。
            String expression = "//OutputData/" + tagName;
            
            // 執行 XPath 查詢，並期望返回一個單一節點 (Node)
            Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);

            if (node != null) {
                // 取得節點內容，並移除前後空白
                String value = node.getTextContent().trim();
                return Optional.of(value);
            }

        } catch (Exception e) {
            // 實務上應該使用 logger.error(...)
            System.err.println("XML 解析錯誤，標籤: " + tagName + ", 錯誤訊息: " + e.getMessage());
        }
        
        return Optional.empty(); // XPath 查詢失敗或節點為空則返回空
    }

    // ... (Main 測試方法可以保留或刪除) ...
}



}



======================測試code========================


import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Map;
import java.util.Optional;

import com.scsb.cfms.entity.ReissueCard;
import com.scsb.cfms.entity.FraudCase;
import com.scsb.cfms.dao.ReissueCardRepository;
import com.scsb.cfms.dao.FraudCaseRepository;
import com.scsb.cfms.util.XmlCardParser;

@ExtendWith(MockitoExtension.class) // 啟用 Mockito
public class ReissueCardTest {

    // 1. 定義測試資料
    private static final String OLD_CARD = "4025128950000127";
    private static final String NEW_CARD = "4025128950000309";
    private static final String REISSUE_NO = "20250809F0001-CARD0001"; // 假的補卡單號
    private static final String CASE_NO = "20250809F0001";   // 假的主單號

    // 範例 XML (PCTF)
    private static final String PCTF_OUTPUT_XML = "<root><OutputData>"
            + "<NEW-ACCT>" + NEW_CARD + "</NEW-ACCT>"
            + "</OutputData></root>";

    // 範例 XML (PCMH)
    private static final String PCMH_OUTPUT_XML = "<OutputData>"
            + "<ACCT-DATA-2>" + NEW_CARD + "</ACCT-DATA-2>"
            + "<TxRetMsg>維護成功</TxRetMsg>"
            + "</OutputData>";



    // 2. 模擬外部依賴
    @Autowired
    private ReissueCardRepository reissueCardRepo;
    @Autowired
    private FraudCaseRepository fraudCaseRepo;
    @Mock
    private XmlCardParser xmlCardParser;
    @SpyBean
    private EaiServiceImpl eaiService;

    @BeforeEach
    void setUp(){
        EaiServiceImpl eaiServiceImpl = new EaiServiceImpl(
                reissueCardRepo,
                fraudCaseRepo,
                xmlCardParser
        );
        eaiService = spy(eaiServiceImpl);
    }

    // =================================================================
    // 測試情境一：首次補卡 (資料庫為空，PCTF 必須執行)
    // =================================================================
    @Test
    void testProcessCardReissue_FirstTimeRun_ShouldCallPctfAndSave() {
        // --- 1. GIVEN (安排/設定) ---

        // a. 準備資料庫回傳的資料
        ReissueCard emptyReissue = new ReissueCard();
        emptyReissue.setReissueNo(REISSUE_NO);
        emptyReissue.setCaseNo(CASE_NO);
        emptyReissue.setReissueCardNo(null); // **關鍵：補發卡號是空的**

        FraudCase fraudCase = new FraudCase();
        fraudCase.setCaseNo(CASE_NO);
        fraudCase.setCardNo(OLD_CARD);

        // b. 模擬 Repository 行為
        when(reissueCardRepo.findByReissueNo(REISSUE_NO)).thenReturn(emptyReissue);
        when(fraudCaseRepo.findFraudCaseByCaseNo(CASE_NO)).thenReturn(fraudCase);

        // c. 模擬 EAI 呼叫 (使用 doReturn().when(spy)... 來模擬 spy 的方法)
        // 模擬 sendPctfRequest，讓它回傳假的 XML
        doReturn(Map.of("outputXML", PCTF_OUTPUT_XML)).when(eaiService).sendPctfRequest(OLD_CARD);

        // 模擬 sendPcmhRequest
        doReturn(Map.of("outputXML", PCMH_OUTPUT_XML)).when(eaiService).sendPcmhRequest(NEW_CARD);

        // d. 模擬 XML 解析
        when(xmlCardParser.extractValueFromXml(PCTF_OUTPUT_XML, "NEW-ACCT"))
                .thenReturn(Optional.of(NEW_CARD));

        when(xmlCardParser.extractValueFromXml(PCMH_OUTPUT_XML, "TxRetMsg"))
                .thenReturn(Optional.of("維護成功"));

        // --- 2. WHEN (執行) ---
        Map<String, String> result = eaiService.processCardReissue(REISSUE_NO, CASE_NO);

        // --- 3. THEN (驗證) ---

        // a. 驗證 PCTF 有被呼叫 1 次
        verify(eaiService, times(1)).sendPctfRequest(OLD_CARD);

        // b. 驗證新卡號有被存到資料庫
        // 抓取 save() 方法的參數
        ArgumentCaptor<ReissueCard> cardCaptor = ArgumentCaptor.forClass(ReissueCard.class);
        verify(reissueCardRepo, times(1)).save(cardCaptor.capture());

        // 檢查被儲存的物件，補發卡號是否已填上
        assertEquals(NEW_CARD, cardCaptor.getValue().getReissueCardNo());

        // c. 驗證 PCMH 也有被呼叫 1 次
        verify(eaiService, times(1)).sendPcmhRequest(NEW_CARD);

        // d. 驗證最終結果
        assertEquals("PCMH_SUCCESS", result.get("status"));
        assertEquals(NEW_CARD, result.get("newCardNumber"));
        assertEquals("維護成功", result.get("txRetMsg"));
    }


    // =================================================================
    // 測試情境二：重複執行 (資料庫已有卡號，PCTF 必須跳過)
    // =================================================================
    @Test
    void testProcessCardReissue_SecondTimeRun_ShouldSkipPctf() {
        // --- 1. GIVEN (安排/設定) ---

        // a. 準備資料庫回傳的資料
        ReissueCard existingReissue = new ReissueCard();
        existingReissue.setReissueNo(REISSUE_NO);
        existingReissue.setCaseNo(CASE_NO);
        existingReissue.setReissueCardNo(NEW_CARD); // **關鍵：補發卡號已存在**

        FraudCase fraudCase = new FraudCase();
        fraudCase.setCaseNo(CASE_NO);
        fraudCase.setCardNo(OLD_CARD);

        // b. 模擬 Repository 行為
        when(reissueCardRepo.findByReissueNo(REISSUE_NO)).thenReturn(existingReissue);
        when(fraudCaseRepo.findFraudCaseByCaseNo(CASE_NO)).thenReturn(fraudCase);

        // c. 模擬 EAI 呼叫 (PCMH 仍然會被呼叫)
        doReturn(Map.of("outputXML", PCMH_OUTPUT_XML)).when(eaiService).sendPcmhRequest(NEW_CARD);

        // --- 2. WHEN (執行) ---
        Map<String, String> result = eaiService.processCardReissue(REISSUE_NO, CASE_NO);

        // --- 3. THEN (驗證) ---

        // a. 驗證 PCTF *沒有* 被呼叫
        verify(eaiService, never()).sendPctfRequest(anyString());

        // b. 驗證資料庫 *沒有* 再次儲存 (因為沒有更新)
        verify(reissueCardRepo, never()).save(any(ReissueCard.class));

        // c. 驗證 PCMH 仍然被呼叫 1 次
        verify(eaiService, times(1)).sendPcmhRequest(NEW_CARD);

        // d. 驗證最終結果 (仍然成功)
        assertEquals("PCMH_SUCCESS", result.get("status"));
        assertEquals(NEW_CARD, result.get("newCardNumber"));
    }
}


========================測試連DB=========================





====== 1105 ReissueCardTest code========

package com.scsb.cfms.service.impl;

//public class ReissueCard {
//
//    public static void main(String[] args) {
//
//
//        String outputPCTF = "";
//        System.out.println(read(outputPCTF));
//
//
//        System.out.println(doPCMH(newAcct));
//
//    }
//
//
////    public String doPCTF() {
////
////    }
//
//
//    public String doPCMH(String newAcct) {
//        return result;
//    }
//
//}

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import com.scsb.cfms.utils.ActionLogger;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Map;
import java.util.Optional;

import com.scsb.cfms.dao.mssql.cfms.model.ReissueCard;
import com.scsb.cfms.dao.mssql.cfms.model.FraudCase;
import com.scsb.cfms.dao.mssql.cfms.repository.FraudCaseRepository;
import com.scsb.cfms.dao.mssql.cfms.repository.ReissueCardRepository;
import com.scsb.cfms.utils.XmlCardParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.transaction.annotation.Transactional;

//@ExtendWith(MockitoExtension.class) // 啟用 Mockito
@SpringBootTest
@Transactional
public class ReissueCardTest {

    // 1. 定義測試資料
    private static final String OLD_CARD = "4025128950000127";
    private static final String NEW_CARD = "4025128950000309";
    private static final String REISSUE_NO = "20250809F0001-CARD0001"; // 假的補卡單號
    private static final String CASE_NO = "20250809F0001";   // 假的主單號
    private static final String PCTF_OUTPUT_XML = "<root><OutputData>"
            + "<NEW-ACCT>" + NEW_CARD + "</NEW-ACCT>"
            + "</OutputData></root>";
    private static final String PCMH_OUTPUT_XML = "<OutputData>"
            + "<ACCT-DATA-2>" + NEW_CARD + "</ACCT-DATA-2>"
            + "<TxRetMsg>維護成功</TxRetMsg>"
            + "</OutputData>";


    @TestConfiguration
    static class TestConfig{
        @Bean
        public XmlCardParser xmlCardParser(){
            return mock(XmlCardParser.class);
        }
        @Bean
        public EaiServiceImpl eaiServiceImpl(
                ReissueCardRepository repo1,
                FraudCaseRepository repo2,
                XmlCardParser parser){
            EaiServiceImpl realService = new EaiServiceImpl(repo1, repo2, parser);
            return spy(realService);
        }
    }

    // 2. 模擬外部依賴
    @Autowired
    private ReissueCardRepository reissueCardRepository;
    @Autowired
    private FraudCaseRepository fraudCaseRepository;
    @Autowired
    private XmlCardParser xmlCardParser;
    @Autowired
    private EaiServiceImpl eaiService;

    @BeforeEach
    void setUp(){
        // a. 資料庫回傳的資料
        ReissueCard reissueCard = new ReissueCard();
        reissueCard.setReissueNo(REISSUE_NO);
        reissueCard.setCaseNo(CASE_NO);
        reissueCard.setReissueCardNo(null); // **關鍵：補發卡號是空的**
        reissueCardRepository.save(reissueCard);

        FraudCase fraudCase = new FraudCase();
        fraudCase.setCaseNo(CASE_NO);
        fraudCase.setCardNo(OLD_CARD);
        fraudCaseRepository.save(fraudCase);

        try{
            // c. 模擬 EAI 呼叫
            // 模擬 sendPctfRequest，讓它回傳假的 XML
            doReturn(Map.of("outputXML", PCTF_OUTPUT_XML)).when(eaiService).sendPctfRequest(OLD_CARD);
            // 模擬 sendPcmhRequest
            doReturn(Map.of("outputXML", PCMH_OUTPUT_XML)).when(eaiService).sendPcmhRequest(NEW_CARD);
        } catch(Exception e){
            ActionLogger.logError("EAI","EAI呼叫失敗");
        }

        // d. 模擬 XML 解析
        when(xmlCardParser.extractValueFromXml(PCTF_OUTPUT_XML, "NEW-ACCT"))
                .thenReturn(Optional.of(NEW_CARD));

        when(xmlCardParser.extractValueFromXml(PCMH_OUTPUT_XML, "TxRetMsg"))
                .thenReturn(Optional.of("維護成功"));
    }

    // =================================================================
    // 測試情境一：首次補卡 (資料庫為空，PCTF 必須執行)
    // =================================================================
    @Test
    void testProcessCardReissue_FirstTimeRun_ShouldCallPctfAndSave() {
        // --- 1. GIVEN (安排/設定) --- (已在 setUp)


        // --- 2. WHEN (執行) ---
        Map<String, String> result = eaiService.processCardReissue(REISSUE_NO, CASE_NO);

        // --- 3. THEN (驗證) ---
        ReissueCard updatedCard = reissueCardRepository.findByReissueNo(REISSUE_NO);

        // c. 驗證 EAI 有被呼叫
        verify(eaiService, times(1)).sendPctfRequest(OLD_CARD);
        verify(eaiService, times(1)).sendPcmhRequest(NEW_CARD);

        // d. 驗證存入DB
        assertNotNull(updatedCard);
        assertEquals(NEW_CARD, updatedCard.getReissueCardNo(), "補發卡號欄位沒有被儲存");

        assertEquals("PCMH_SUCCESS", result.get("status"));

    }


    // =================================================================
    // 測試情境二：重複執行 (資料庫已有卡號，PCTF 必須跳過)
    // =================================================================
    @Test
    void testProcessCardReissue_SecondTimeRun_ShouldSkipPctf() {
        // --- 1. GIVEN (安排/設定) ---

        // a. 已有卡號的資料
        ReissueCard existingReissue = reissueCardRepository.findByReissueNo(REISSUE_NO);
        existingReissue.setReissueCardNo(NEW_CARD); // **關鍵：補發卡號已存在**
        reissueCardRepository.save(existingReissue);


        // c. 模擬 EAI 呼叫 (PCMH 仍然會被呼叫)
//        doReturn(Map.of("outputXML", PCMH_OUTPUT_XML)).when(eaiService).sendPcmhRequest(NEW_CARD);

        // --- 2. WHEN (執行) ---
        Map<String, String> result = eaiService.processCardReissue(REISSUE_NO, CASE_NO);

        // --- 3. THEN (驗證) ---

        // a. 驗證 PCTF *沒有* 被呼叫
        verify(eaiService, never()).sendPctfRequest(anyString());

        // b. 驗證資料庫 *沒有* 再次儲存 (因為沒有更新)
        verify(reissueCardRepository, never()).save(any(ReissueCard.class));

        // c. 驗證 PCMH 仍然被呼叫 1 次
        verify(eaiService, times(1)).sendPcmhRequest(NEW_CARD);

        // d. 驗證最終結果 (仍然成功)
        assertEquals("PCMH_SUCCESS", result.get("status"));
        assertEquals(NEW_CARD, result.get("newCardNumber"));
    }
}



