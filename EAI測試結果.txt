EAI測試結果

===========PCTF============
<root>
  <InputData>
    <ORG/>
    <TYPE/>
    <CARDHOLDER>4573780000000006</CARDHOLDER>
    <EMG/>
    <BLOCK-CDE/>
    <NEW-ACCT/>
    <DATE-TRANS-EFFECT/>
    <UPDATE-EXCEPTION-FILE/>
  </InputData>
  <OutputData>
    <ORG>001  </ORG>
    <TYPE>370 </TYPE> 利被商務玉璽卡 VISA
    <CARDHOLDER>4573780000000006</CARDHOLDER>
    <EMG>         </EMG>
    <BLOCK-CDE>L</BLOCK-CDE>
    <NEW-ACCT>4573780000000105</NEW-ACCT>
    <DATE-TRANS-EFFECT>10092025</DATE-TRANS-EFFECT>
    <UPDATE-EXCEPTION-FILE>N</UPDATE-EXCEPTION-FILE>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>
</root>


<root>
  <InputData>
    <ORG/>
    <TYPE/>
    <CARDHOLDER>4025128950000127</CARDHOLDER>
    <EMG/>
    <BLOCK-CDE/>
    <NEW-ACCT/>
    <DATE-TRANS-EFFECT/>
    <UPDATE-EXCEPTION-FILE/>
  </InputData>
  <OutputData>
    <ORG>001  </ORG>
    <TYPE>195 </TYPE>  
    <CARDHOLDER>4025128950000127</CARDHOLDER>
    <EMG>         </EMG>
    <BLOCK-CDE>L</BLOCK-CDE>
    <NEW-ACCT>4025128950000309</NEW-ACCT>
    <DATE-TRANS-EFFECT>10092025</DATE-TRANS-EFFECT>
    <UPDATE-EXCEPTION-FILE>N</UPDATE-EXCEPTION-FILE>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>
</root>
 ONE卡 type: 191 195 291 391 395 397


4573780000000014
<root>
  <InputData>
    <ORG/>
    <TYPE/>
    <CARDHOLDER>4573780000000014 </CARDHOLDER>
    <EMG/>
    <BLOCK-CDE/>
    <NEW-ACCT/>
    <DATE-TRANS-EFFECT/>
    <UPDATE-EXCEPTION-FILE/>
  </InputData>
  <OutputData>
    <ORG>001  </ORG>
    <TYPE>370 </TYPE>
    <CARDHOLDER>4573780000000014</CARDHOLDER>
    <EMG>         </EMG>
    <BLOCK-CDE>L</BLOCK-CDE>
    <NEW-ACCT>4573780000000204</NEW-ACCT>
    <DATE-TRANS-EFFECT>11092025</DATE-TRANS-EFFECT>
    <UPDATE-EXCEPTION-FILE>N</UPDATE-EXCEPTION-FILE>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>
</root>




=============================PCMH===============================

0006新卡號 4573780000000105  error?
<root>
  <OutputData>
    <ACCT-DATA-1>370</ACCT-DATA-1>
    <ACCT-DATA-2>4573780000000105  </ACCT-DATA-2>
    <TxRetMsg>INPUT DATA ERROR</TxRetMsg>
  </OutputData>
</root>


PCMH xml 4563148170008211 有無改參數都成功
<OutputData>
    <ACCT-DATA-1>217</ACCT-DATA-1>
    <ACCT-DATA-2>4563148170008203  </ACCT-DATA-2>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>

0127新卡號 4025128950000309 有無改參數都成功
<OutputData>
    <ACCT-DATA-1>195</ACCT-DATA-1>
    <ACCT-DATA-2>4025128950000309  </ACCT-DATA-2>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>

0014新卡號 4573780000000204 
<OutputData>
    <ACCT-DATA-1>370</ACCT-DATA-1>
    <ACCT-DATA-2>4573780000000204  </ACCT-DATA-2>
    <TxRetMsg>INPUT DATA ERROR</TxRetMsg>
  </OutputData>

<OutputData> OK了
    <ACCT-DATA-1>370</ACCT-DATA-1>
    <ACCT-DATA-2>4573780000000204  </ACCT-DATA-2>
    <TxRetMsg>維護成功</TxRetMsg>
  </OutputData>


===================TODO=====================
補卡單上多按鈕 補卡 
編輯時才可點
原本輸入新卡號(有指定卡號的)
點補卡後直接帶入無指定的 純顯示 createtd? 


action code 看要不要做控管 只有那八種type可以修改 防止誤敲報錯
action code & Expired date 都讓user敲


===================解析xml=====================


package com.scsb.cfms.util;

import org.springframework.stereotype.Component;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;
import java.io.IOException;
import java.io.StringReader;
import java.util.Optional;

@Component
public class XmlCardParser {

    // 建議使用 Logger 而非 System.err
    // private static final Logger logger = LogManager.getLogger(XmlCardParser.class); 

    /**
     * 安全地解析 EAI 回傳的 XML 字串，並使用 XPath 提取指定標籤的值。
     *
     * @param xmlString EAI 回傳的完整 XML 字串。
     * @param tagName 要提取值的標籤名稱，例如 "NEW-ACCT" 或 "TxRetMsg"。
     * @return 提取到的標籤值，如果找不到或解析失敗則返回空 Optional。
     */
    public Optional<String> extractValueFromXml(String xmlString, String tagName) {
        if (xmlString == null || xmlString.isBlank() || tagName == null || tagName.isBlank()) {
            return Optional.empty();
        }

        try {
            // =====================================
            // 1. 安全初始化 XML 解析器 (XXE 防禦)
            // =====================================
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

            // *** 關鍵的安全設定：禁用外部實體解析 ***
            factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
            factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
            factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
            factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
            factory.setExpandEntityReferences(false);
            // **********************************

            DocumentBuilder builder = factory.newDocumentBuilder();
            
            // 2. 解析 XML 字串
            Document document = builder.parse(new InputSource(new StringReader(xmlString)));
            
            // =====================================
            // 3. 使用 XPath 進行精確查詢
            // =====================================
            XPath xpath = XPathFactory.newInstance().newXPath();

            // XPath 表達式：//OutputData/tagName
            // 意義：在 XML 文件中的任何位置，找到 <OutputData> 標籤下的 <tagName> 標籤。
            // 這樣可以避免 <InputData> 中同名標籤的干擾。
            String expression = "//OutputData/" + tagName;
            
            // 執行 XPath 查詢，並期望返回一個單一節點 (Node)
            Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);

            if (node != null) {
                // 取得節點內容，並移除前後空白
                String value = node.getTextContent().trim();
                return Optional.of(value);
            }

        } catch (Exception e) {
            // 實務上應該使用 logger.error(...)
            System.err.println("XML 解析錯誤，標籤: " + tagName + ", 錯誤訊息: " + e.getMessage());
        }
        
        return Optional.empty(); // XPath 查詢失敗或節點為空則返回空
    }

    // ... (Main 測試方法可以保留或刪除) ...
}





    // 測試範例
    public static void main(String[] args) {
        String pctfXmlOutput = "<root>\n" +
                "  <InputData>\n" +
                "    <ORG/>\n" +
                "    <TYPE/>\n" +
                "    <CARDHOLDER>4573780000000006</CARDHOLDER>\n" +
                "    <EMG/>\n" +
                "    <BLOCK-CDE/>\n" +
                "    <NEW-ACCT/>\n" +
                "    <DATE-TRANS-EFFECT/>\n" +
                "    <UPDATE-EXCEPTION-FILE/>\n" +
                "  </InputData>\n" +
                "  <OutputData>\n" +
                "    <ORG>001  </ORG>\n" +
                "    <TYPE>370 </TYPE>\n" +
                "    <CARDHOLDER>4573780000000006</CARDHOLDER>\n" +
                "    <EMG>         </EMG>\n" +
                "    <BLOCK-CDE>L</BLOCK-CDE>\n" +
                "    <NEW-ACCT>4573780000000105</NEW-ACCT>\n" +
                "    <DATE-TRANS-EFFECT>10092025</DATE-TRANS-EFFECT>\n" +
                "    <UPDATE-EXCEPTION-FILE>N</UPDATE-EXCEPTION-FILE>\n" +
                "    <TxRetMsg>維護成功</TxRetMsg>\n" +
                "  </OutputData>\n" +
                "</root>";

        Optional<String> newCardNumber = extractValueFromXml(pctfXmlOutput, "NEW-ACCT");
        
        if (newCardNumber.isPresent()) {
            System.out.println("提取到的新卡號: " + newCardNumber.get()); // 輸出: 4573780000000105
        } else {
            System.out.println("無法提取新卡號。");
        }
    }
}



===================測試code=====================


import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Map;
import java.util.Optional;

// 引入您的 Entity 和 Repository
import com.scsb.cfms.entity.ReissueCard;
import com.scsb.cfms.entity.FraudCase;
import com.scsb.cfms.dao.ReissueCardRepository;
import com.scsb.cfms.dao.FraudCaseRepository;
import com.scsb.cfms.util.XmlCardParser;

@ExtendWith(MockitoExtension.class) // 啟用 Mockito
public class EaiServiceImplTest {

    // 1. 定義測試資料
    private static final String OLD_CARD = "4025128950000127";
    private static final String NEW_CARD = "4025128950000309";
    private static final String REISSUE_NO = "R001"; // 假的補卡單號
    private static final String CASE_NO = "C001";   // 假的主單號

    // 您提供的範例 XML (PCTF)
    private static final String PCTF_OUTPUT_XML = "<root><OutputData>"
            + "<NEW-ACCT>" + NEW_CARD + "</NEW-ACCT>"
            + "</OutputData></root>";

    // 您提供的範例 XML (PCMH)
    private static final String PCMH_OUTPUT_XML = "<OutputData>"
            + "<ACCT-DATA-2>" + NEW_CARD + "</ACCT-DATA-2>"
            + "<TxRetMsg>維護成功</TxRetMsg>"
            + "</OutputData>";

    // 2. 模擬外部依賴
    @Mock
    private ReissueCardRepository reissueCardRepo;
    @Mock
    private FraudCaseRepository fraudCaseRepo;
    @Mock
    private XmlCardParser xmlCardParser;

    // 3. 監視並注入我們要測試的 Service
    @Spy // 使用 Spy 來監視真實物件
    @InjectMocks // 將上面的 @Mock 元件注入到 eaiService 中
    private EaiServiceImpl eaiService;

    // =================================================================
    // 測試情境一：首次補卡 (資料庫為空，PCTF 必須執行)
    // =================================================================
    @Test
    void testProcessCardReplacement_FirstTimeRun_ShouldCallPctfAndSave() {
        // --- 1. GIVEN (安排/設定) ---

        // a. 準備資料庫回傳的資料
        ReissueCard emptyReissue = new ReissueCard();
        emptyReissue.setReissueNo(REISSUE_NO);
        emptyReissue.setCaseNo(CASE_NO);
        emptyReissue.setReissueCardNo(null); // **關鍵：補發卡號是空的**

        FraudCase fraudCase = new FraudCase();
        fraudCase.setCaseNo(CASE_NO);
        fraudCase.setCardNo(OLD_CARD);

        // b. 模擬 Repository 行為
        when(reissueCardRepo.findById(REISSUE_NO)).thenReturn(Optional.of(emptyReissue));
        when(fraudCaseRepo.findById(CASE_NO)).thenReturn(Optional.of(fraudCase));

        // c. 模擬 EAI 呼叫 (使用 doReturn().when(spy)... 來模擬 spy 的方法)
        // 模擬 sendPctfRequest，讓它回傳假的 XML
        doReturn(Map.of("outputXML", PCTF_OUTPUT_XML))
            .when(eaiService).sendPctfRequest(OLD_CARD);
        
        // 模擬 sendPcmhRequest
        doReturn(Map.of("outputXML", PCMH_OUTPUT_XML))
            .when(eaiService).sendPcmhRequest(NEW_CARD);

        // d. 模擬 XML 解析
        when(xmlCardParser.extractValueFromXml(PCTF_OUTPUT_XML, "NEW-ACCT"))
            .thenReturn(Optional.of(NEW_CARD));
        
        // --- 2. WHEN (執行) ---
        Map<String, String> result = eaiService.processCardReplacement(REISSUE_NO);

        // --- 3. THEN (驗證) ---

        // a. 驗證 PCTF 有被呼叫 1 次
        verify(eaiService, times(1)).sendPctfRequest(OLD_CARD);

        // b. 驗證新卡號有被存到資料庫
        // 抓取 save() 方法的參數
        ArgumentCaptor<ReissueCard> cardCaptor = ArgumentCaptor.forClass(ReissueCard.class);
        verify(reissueCardRepo, times(1)).save(cardCaptor.capture());
        
        // 檢查被儲存的物件，補發卡號是否已填上
        assertEquals(NEW_CARD, cardCaptor.getValue().getReissueCardNo());

        // c. 驗證 PCMH 也有被呼叫 1 次
        verify(eaiService, times(1)).sendPcmhRequest(NEW_CARD);

        // d. 驗證最終結果
        assertEquals("SUCCESS", result.get("status"));
        assertEquals(NEW_CARD, result.get("newCardNumber"));
    }

    // =================================================================
    // 測試情境二：重複執行 (資料庫已有卡號，PCTF 必須跳過)
    // =================================================================
    @Test
    void testProcessCardReplacement_SecondTimeRun_ShouldSkipPctf() {
        // --- 1. GIVEN (安排/設定) ---

        // a. 準備資料庫回傳的資料
        ReissueCard existingReissue = new ReissueCard();
        existingReissue.setReissueNo(REISSUE_NO);
        existingReissue.setCaseNo(CASE_NO);
        existingReissue.setReissueCardNo(NEW_CARD); // **關鍵：補發卡號已存在**

        FraudCase fraudCase = new FraudCase();
        fraudCase.setCaseNo(CASE_NO);
        fraudCase.setCardNo(OLD_CARD);

        // b. 模擬 Repository 行為
        when(reissueCardRepo.findById(REISSUE_NO)).thenReturn(Optional.of(existingReissue));
        when(fraudCaseRepo.findById(CASE_NO)).thenReturn(Optional.of(fraudCase));

        // c. 模擬 EAI 呼叫 (PCMH 仍然會被呼叫)
        doReturn(Map.of("outputXML", PCMH_OUTPUT_XML))
            .when(eaiService).sendPcmhRequest(NEW_CARD);
        
        // --- 2. WHEN (執行) ---
        Map<String, String> result = eaiService.processCardReplacement(REISSUE_NO);

        // --- 3. THEN (驗證) ---

        // a. 驗證 PCTF *絕對沒有* 被呼叫
        verify(eaiService, never()).sendPctfRequest(anyString());

        // b. 驗證資料庫 *絕對沒有* 再次儲存 (因為沒有更新)
        verify(reissueCardRepo, never()).save(any(ReissueCard.class));

        // c. 驗證 PCMH 仍然被呼叫 1 次
        verify(eaiService, times(1)).sendPcmhRequest(NEW_CARD);
        
        // d. 驗證最終結果 (仍然成功)
        assertEquals("SUCCESS", result.get("status"));
        assertEquals(NEW_CARD, result.get("newCardNumber"));
    }
}


===測試結果===

OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended

java.lang.NullPointerException: Cannot invoke "com.scsb.cfms.dao.mssql.cfms.repository.ReissueCardRepository.findByReissueNo(String)" because "<local4>.reissueCardRepository" is null

	at com.scsb.cfms.service.impl.EaiServiceImpl.processCardReissue(EaiServiceImpl.java:71)
	at com.scsb.cfms.service.impl.EaiServiceImpl.processCardReissue(EaiServiceImpl.java:70)
	at com.scsb.cfms.service.impl.ReissueCardTest.testProcessCardReissue_FirstTimeRun_ShouldCallPctfAndSave(ReissueCardTest.java:117)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)


Process finished with exit code -1


